{"title":"贾小强的博客","description":"在痛苦中成长，在成长中感受痛苦","language":"zh-CN","link":"//qiangck.club","pubDate":"Thu, 11 Apr 2019 09:39:00 GMT","lastBuildDate":"Tue, 30 Jul 2019 02:08:38 GMT","generator":"hexo-generator-json-feed","webMaster":"qiangck","items":[{"title":"Hello World","link":"//qiangck.club/2019/04/11/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Thu, 11 Apr 2019 09:39:00 GMT","guid":"//qiangck.club/2019/04/11/hello-world/","category":"dddd"},{"title":"放弃npm拥抱yarn","link":"//qiangck.club/2016/12/28/放弃npm拥抱yarn/","description":"yarn介绍 Yarn 是Facebook最近发布的一款依赖包安装工具. 官方认为其快速, 安全, 可靠。你下载的包将不再重新下载。而且确保在不同系统中可以正常工作。(Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don’t ever have to worry.) yarn优点 一致性：Yarn允许使用某个lockfile来保证团队中的所有人使用相同版本的npm依赖包，这一点会大大减少因为某个人系统本身问题而导致的Bug 多样性： Yarn还允许用户将npm包以tar.gz形式打包上传到版本控制系统中，这一点能够利用NPM包本身已经对不同版本的Node或者操作系统做了容错这一特性 离线： Yarn允许离线安装某些依赖，这点对于CI系统特别适用。CI系统就不需要保证有稳定的网络连接，特别是在有墙的地方 速度： Yarn采用了新的算法来保证速度， 比NPM快到2~7倍， 同时也允许使用离线包的方式本地安装依赖 安全： 下载前会检查签名及包的完整性 网络优化 ：力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败 扁平化： 对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的 缓存：缓存已经下载过的包，避免重复下载 yarn命令 yarn init: 初始化某个项目 yarn install/link: 默认的安装依赖操作 yarn add taco: 安装某个依赖，并且默认保存到package yarn remove taco: 移除某个依赖项目 yarn add taco —dev: 安装某个开发时依赖项目 yarn upgrade taco: 更新某个依赖项目 yarn global add taco: 安装某个全局依赖项目 yarn publish/login/logout: 发布/登录/登出，一系列NPM Registry操作 yarn run/test: 运行某个命令 yarn安装 这里我只说mac的安装方法，win安装较为简单，可以使用npm的方式安装。 1.安装Homebrew包管理工具，方便快捷，一条指令即可安装完成。 /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.安装yarn。 brew update brew install yarn 3.验证安装是否完成，如果有显示版本号说明安装完成。 yarn --version 开始使用yarn 如果已有repo，则删除node_modules，使用“yarn”命令进行重新安装；如果新repo则直接使用“yarn“命令安装，可以对npm项目进行无缝衔接 rm -rf node_modules yarn","pubDate":"Wed, 28 Dec 2016 15:50:00 GMT","guid":"//qiangck.club/2016/12/28/放弃npm拥抱yarn/","category":"yarn"},{"title":"HTML5 WebSocket介绍","link":"//qiangck.club/2016/06/15/HTML5-WebSocket介绍/","description":"WebSocket是一种基于ws协议的技术，它可以建立全双工连接，常见于浏览器，但是不受平台限制，这里只介绍浏览器相关的内容。 浏览器支持 Chrome Firefox Internet Explorer Opera Safari &gt;16 &gt;11 &gt;10 &gt;12.1 &gt;7 请求 ws开头是普通的websocket连接，wss是安全的websocket连接，类似于https。 客户端到服务端 GET /echo HTTP/1.1Upgrade: WebSocketConnection: UpgradeHost: 127.0.0.1:9999Origin: http://127.0.0.0.1 服务端到客户端 HTTP/1.1 101 Web Socket Protocol HandshakeUpgrade: WebSocketConnection: UpgradeWebSocket-Origin: http://127.0.0.0.1WebSocket-Location: ws://127.0.0.1:9999 WebSocket 服务器端 Kaazing WebSocket Gateway：一个 Java 实现的 WebSocket Server mod_pywebsocket：一个 Python 实现的 WebSocket Server Netty：一个 Java 实现的网络框架其中包括了对 WebSocket 的支持 node.js：一个 Server 端的 JavaScript 框架提供了对 WebSocket 的支持 WebSocket 应用 1.创建一个 WebSocket 对象 1var ws = new WebSocket(\"ws://127.0.0.1：9999\", protocols); protocols【可选】:可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。 一旦连接建立（也就是说 readyState 变成 OPEN），ws 将会告诉你服务器选择了哪一种协议。 状态readyState 值 介绍 CONNECTING 0 连接还没开启。 OPEN 1 连接已开启并准备好进行通信 CLOSING 2 连接正在关闭的过程中 CLOSED 3 连接已经关闭，或者连接无法建立 2.发送数据到服务器 1ws.onopen = function (event) &#123; ws.send(\"sucess\"); &#125;; 建立连接的过程是异步的，而且可能会出错，因此刚刚连接就调用 send() 可能会失败。 我们可以设置 onopen 回调函数来确定什么时候连接成功。 3.使用 JSON 来传输接收数据 传输： 需要把要传的对象Object转成JSON，JSON.stringify(obj); 接收： 需要把接受的数据转成对象Object，JSON.parse(JSON); 4.事件描述 onmessage：一个用于消息事件的事件监听器，这一事件当有消息到达的时候该事件会触发。这个事件会被传入一个名为”message”的对象 onopen：一个用于连接打开事件的事件监听器。当readyState的值变为OPEN的时候会触发该事件。该事件表明这个连接已经准备好接受和发送数据。这个监听器会接受一个名为”open”的事件对象 onclose：用于监听连接关闭事件监听器。当WebSocket对象的readyState状态变为CLOSED时会出发该事件。这个监听器会接收一个叫close的事件对象 onerror：当错误发生时用于监听error事件的事件监听器。会接受一个名为error的event对象 注意事项 在 Gecko 9之前的版本上，UTF-8 文本里的某些非文本字符会导致连接断开，但是现在的 Gecko 已经解决了这个问题。 不要将 WebSockets 用于混合内容环境；不要在 HTTPS 安全页面下创建非安全的 WebSocket 连接，反之亦然。有些浏览器对此是强行禁止的，例如 Firefox 8 和后续版本。 从Gecko 6.0开始，构造器含有前缀，你需要调用 MozWebSocket()，直到 Gecko 8.0 才被支持 WebSocket。 在 Gecko 11.0之前，用send()方法发送的数据被限制在16MB以内。现在数据大小可以达到2 GB。","pubDate":"Wed, 15 Jun 2016 08:50:00 GMT","guid":"//qiangck.club/2016/06/15/HTML5-WebSocket介绍/","category":"HTML5"},{"title":"favicon.ico重复请求问题","link":"//qiangck.club/2016/04/03/favicon-ico重复请求问题/","description":"favicon.ico图标用于收藏夹图标和浏览器标签上的显示，如果不设置，浏览器会请求网站根目录的这个图标，如果网站根目录也没有这图标会产生 404的请求，并会重复请求，出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求，在移动端下不希望产生favicon.ico的请求，可以在页面的’‘区域，加上如下代码实现屏蔽：1234&lt;!-- 简洁版 --&gt;&lt;link rel=\"icon\" href=\"data:;base64,=\"/&gt;&lt;!-- 完整版 --&gt;&lt;link rel=\"icon\" href=\"data:image/ico;base64,aWNv\"/&gt;","pubDate":"Sat, 02 Apr 2016 17:44:00 GMT","guid":"//qiangck.club/2016/04/03/favicon-ico重复请求问题/","category":"HTML5"},{"title":"弹性盒模型的简单使用","link":"//qiangck.club/2015/11/12/弹性盒模型的简单使用/","description":"基本使用方法 Flexible Box(弹性盒子)能让页面的分布更合理和方便，这是之前使用常规的布局方式所做不到的。 123456&lt;div class=\"warp\"&gt; &lt;div class=\"modular\"&gt;1&lt;/div&gt; &lt;div class=\"modular\"&gt;2&lt;/div&gt; &lt;div class=\"modular\"&gt;3&lt;/div&gt; &lt;div class=\"modular\"&gt;4&lt;/div&gt;&lt;/div&gt; display:flex和display:box有什么区别？ 前者是flex 2012年的语法，也将是以后标准的语法，大部分浏览器已经实现了无前缀版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.warp&#123; width: 100%; height: 100px; /*这个是用来定义伸缩容器，是内联还是块取决于设置的值。*/ /*这个时候，他的所有子元素将变成flex文档流，称为伸缩项目。*/ /*---------------------*/ display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */ display: -moz-box; /* Firefox 17- */ display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */ display: -moz-flex; /* Firefox 18+ */ display: -ms-flexbox; /* IE 10 */ display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */ /*---------------------*/ /*一起使用box-align 和 box-pack 属性，对子元素进行居中*/ -webkit-box-pack:justify; -webkit-box-align: ustify; -moz-box-pack:justify; -moz-box-align:justify; box-pack:justify; box-align:justify; /*---------------------*/ /*定义了伸缩项目放置在伸缩容器的方向*/ flex-direction:row; -webkit-flex-direction:row; /*定义伸缩容器里是单行还是多行显示*/ flex-wrap:nowrap; /*flex-direction”和“flex-wrap”属性的缩写版本,默认row nowrap*/ flex-flow:row nowrap; /*设置伸缩容器在横向方向上的对齐方式。*/ justify-content:center; /*设置伸缩容器在纵向方向上的对齐方式。*/ align-items:center; /*当伸缩容器的纵向还有多余空间时，可以用来调准伸缩容器横向在伸缩容器里的对齐方式*/ align-content:center;&#125; /*子级*/.warp .modular&#123; width:80px; height:80px; background-color:#eee; text-align:center; /*设置伸缩项目出現的順序。*/ order:-1; /*设置伸缩项目扩展的比例。*/ flex-grow:1; /*设置伸缩项目收缩的比例。*/ flex-shrink:2; /*设置伸缩项目的伸缩基准值。*/ flex-basis:auto; /*flex-grow”、“flex-shrink”和“flex-basis”三个属性的缩写*/ flex:1 2 100px; /*用来在单独的伸缩项目上覆写默认的对齐方式。*/ align-self:center;&#125; 直接上代码，写了个Demo便于理解,其中warp为父元素，称为“伸缩容器，modular为子元素，称为“伸缩项目”。 应用场景 Flexbox布局最适合应用程序的组件和小规模的布局，而网格布局更适合那些更大规模的布局。 目前没有浏览器支持 box-flex 属性，Firefox 支持替代的 -moz-box-flex 属性，Safari、Opera 以及 Chrome 支持替代的 -webkit-box-flex 属性。 CSS的columns在伸缩容器上没有效果。 float、clear和vertical-align在伸缩项目上没有效果。 例：移动端导航（居中，左右，自适应居中，自适应竖向排列） 12345678910111213141516171819202122232425262728293031323334353637&lt;style type=\"text/css\"&gt; .nav&#123; background:#00BFFF; display:-webkit-box; display:-moz-box; display:-ms-flexbox; display:-webkit-flex; display:flex; -webkit-flex-flow:row wrap; /*自适应竖向排列*/ -webkit-flex-flow:column wrap; /* 所有列面向主轴起始位置靠齐 */ justify-content:flex-start; /* 所有列面向主轴终点位置靠齐 */ justify-content:flex-end; &#125; .nav a&#123; text-decoration:none; display:block; padding:1em; color:#fff; /*居中平铺*/ flex:1; &#125; @media all and (max-width: 800px) &#123; .nav&#123; /* 所有列面向主轴两端位置平均分配 */ justify-content:space-around; &#125; &#125;&lt;/style&gt;&lt;ul class=\"nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 例：移动端常用自适应布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;style type=\"text/css\"&gt; .wrapper&#123; display:-webkit-box; display:-moz-box; display:-ms-flexbox; display:-webkit-flex; display:flex; -webkit-flex-flow:row wrap; flex-flow:row wrap; &#125; .wrapper &gt; *&#123; padding:10px; flex:1 100%; &#125; .header&#123; background:#FF6347; &#125; .footer&#123; background:#90EE90; &#125; .main&#123; background:#00BFFF; &#125; .aside-1&#123; background:#FFD700; &#125; .aside-2&#123; background:#FF69B4; &#125; @media all and (min-width: 600px) &#123; .aside&#123; flex:1 auto; &#125; &#125; @media all and (min-width: 800px) &#123; .main&#123; flex:3 0px; &#125; .aside-1&#123; order:1; &#125; .main&#123; order:2; &#125; .aside-2&#123; order:3; &#125; .footer&#123; order:4; &#125; &#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;header class=\"header\"&gt;顶部&lt;/header&gt; &lt;article class=\"main\"&gt; &lt;p&gt;我在中间显示的文字&lt;/p&gt; &lt;/article&gt; &lt;aside class=\"aside aside-1\"&gt;我在左边显示的文字&lt;/aside&gt; &lt;aside class=\"aside aside-2\"&gt;我在右边显示的文字&lt;/aside&gt; &lt;footer class=\"footer\"&gt;底部&lt;/footer&gt;&lt;/div&gt;","pubDate":"Thu, 12 Nov 2015 03:36:00 GMT","guid":"//qiangck.club/2015/11/12/弹性盒模型的简单使用/","category":"css"},{"title":"Deferred对象与异步编程","link":"//qiangck.club/2015/11/03/Deferred对象与异步编程/","description":"以Deferred方式执行Ajax回调 123456789101112131415161718192021$.ajax('/test').done(function(data)&#123; //请求成功后的操作 alert('done1');&#125;).done(function()&#123; //请求成功后的操作 alert('done2');&#125;).fail(function()&#123; //请求失败后的操作 alert('fail');&#125;).always(function()&#123; //请求完成后的操作 alert('always');&#125;);$.ajax('/test').then(function()&#123; //如果成功执行 alert('success');&#125;,function()&#123; //如果失败执行 alert('error');&#125;); 例：Deferred的实现方法 1234567891011121314151617181920212223242526//常规方式function testDeferred()&#123; setTimeout(function()&#123; var val = Math.random(); if(val &gt; 0.5)&#123; alert('done' + val); &#125;else&#123; alert('fail' + val); &#125; &#125;,100);&#125;//使用Deferred方式function tt()&#123; var defer = $.Deferred(); setTimeout(function()&#123; var val = Math.random(); var &gt; 0.5 ? defer.resolve(val) : defer.reject(val); &#125;,100); return defer;&#125;tt().done(function(data)&#123; alert('done' + data);&#125;).fail(function(data)&#123; alert('fail' + data);&#125;); 例：多个请求同时发起(when) 1234567891011$.when( $.ajax('/test?err=n&amp;a=1'), $.ajax('/test?err=n&amp;a=2'), $.ajax('/test?err=n&amp;a=3')).then(function()&#123; alert('success'); console.log(arguments);&#125;,function(promise,statusText,errObj)&#123; alert('error'); console.log(arguments);&#125;); 例：多个请求一次发起(then) 1234567891011$.ajax('/test?err=n').then(function()&#123; alert('success'); //如果成功执行，并返回 return $.ajax('/test')；&#125;,function()&#123; alert('error1'); //如果失败执行，并返回 return $.ajax('/test?a=no')；&#125;).then(function()&#123; alert('success2');&#125;);","pubDate":"Tue, 03 Nov 2015 03:09:00 GMT","guid":"//qiangck.club/2015/11/03/Deferred对象与异步编程/","category":"jQuery"},{"title":"jQuery $.ajax详解使用方法","link":"//qiangck.club/2015/11/03/jQuery-ajax详解使用方法/","description":"$.ajax快捷方法 $.get(url,[data],[callback],[type])$.post(url,[data],[callback],[type]) 两种方法请求方式不同，其他方式相同 参数：url[请求地址]，data[请求的数据内容(obj对象)]，callback[回调函数(只能处理请求成功事件)]，type[请求返回数据的编码格式(默认ContentType指定格式)] 12345678$.get('/test?x=1');$.get('/test',&#123;z:2&#125;);$.post('/test',&#123;y:2&#125;);$.get('/user',function(data,callbacktype,jqXHR)&#123; data//返回数据 callbacktype//返回数据的状态信息(字符串) jqXHR//jQuery封装的XHR对象&#125;); $(selector).load(url,[data],[callback]) 将页面片段载入到selector的容器里面 1$(\"#content\").load('/user'); $.getJSON(url,[data],[callback]) 如果是JSON数据回调会成功，否则失败 123$.getJSON('/test',&#123;type:1&#125;,function()&#123; console.log(argument)&#125;); $.getScript(url,[claaback]) 动态加载脚本文件 123$.gerScript('/js/test.js',function()&#123; alert(test(1,2));&#125;); $.ajax详细使用方法 $.ajax(url,[settings]); 123456$.ajax(&#123; url:'/test', success:function()&#123; alert('ok'); &#125;&#125;); 处理响应结果的回调函数： success[成功]，error[请求失败]， statusCode[指明返回的状态码的回调函数], complete[请求返回前的回调函数(处理返回不同状态码的请求)] 12345678910111213141516171819202122232425262728$.ajax('/test',&#123; success:function(data)&#123; console.log(arguments); &#125;, error:function(jqXHR,textStatus,err)&#123; //jqXHR:jQuery增强的XHR //textStatus:请求完成状态 //err:底层通过throw抛出的异常对象，类型与值与错误类型有关 console.log(arguments); &#125;, complete:function(jqXHR,textStatus)&#123; //jqXHR:jQuery增强的XHR //textStatus：请求完成状态success | error console.log(arguments); &#125;, statusCode:function()&#123; '403':function(jqXHR,textStatus,err)&#123; //jqXHR:jQuery增强的XHR //textStatus:请求完成状态 //err:底层通过throw抛出的异常对象，类型与值与错误类型有关 console.log(arguments); console.log(400); &#125;, '400':function()&#123; console.log(400); &#125; &#125; &#125;); 请求的数据：data,processData,contentType,traditional 123456789101112131415$.ajax('/test',&#123; //请求的数据内容 data:&#123; a:1, b:2 &#125;, //请求的方式 type:'POST', //是否对请求的数据进行转码(用于传输数据为html节点内容) processData:true, //当前的数据是否使用传统方式进行url编码 traditional:true, //请求数据编码格式 contentType:'application/json'&#125;); 响应数据：dataType,dataFilter 123456789101112$.ajax('/test',&#123; success:function(data)&#123; console.log(typeof data) &#125;, //定义的返回数据的类型 dataType:'json | html | text | jsonp | script', //返回底层的原始数据进行预处理 dataFilter:function(data,type)&#123; //data:原始数据 //type:指定的数据类型 &#125; &#125;); 前置处理：beforeSend 12345678910$.ajax('/test',&#123; beforeSend:function(jqXHR,settings)&#123; console.log(arguments); jqXHR.setRequestHeader('test','haha'); jqXHR.testData = &#123;a:1,b:2&#125;; &#125;, complete:function(jqXHR)&#123; console.log(jqXHR.testData) &#125;&#125;); 请求类型：GET(默认) | POST | PUT | DELETE 同步异步：async(默认true) 是否缓存：cache(默认true) 其他参数： global：是否触发全局事件 ifModifed：仅在服务器数据改变时候加载数据 username,password：http需要验证时候 timeout：设置请求超时时间，若请求超时触发error context：回调中this指向的对象 其他相关的API $.ajaxSetup(option) 设置全局默认参数 1234567891011121314//默认为get请求$.ajax('/test');//修改全局请求方式为post$.ajaxSetup(&#123; type:'post', headers:&#123; test:new Date().getTime &#125;, cache:false&#125;);//请求方式改变为post$.ajax('/test'); $.ajaxPrefilter([dataTypes],handler(option,originalOptions,jqXHR)) 请求发起前的预处理，提供了一种AOP(面向切面)编程模式，常见用途： 根据option设定执行特定处理逻辑 修改option值改变请求默认行为 通过return修改默认dataType 例：通过return修改默认dataType 12345678910111213141516$.ajaxPrefilter('text html json',function(options,originalOptions,jqXHR)&#123; //options请求参数，含默认值 //originalOptions请求时传入的参数，不含默认值 //jqXHR:jQuery增强的XHR console.log(arguments); if(options.url == '/test')&#123; return 'text'; &#125;&#125;);$.ajax('/test',&#123; type:'post', dataType:'text', //自定义属性 test:'haha'&#125;); 例：多次请求仅最后一次有效，避免多次请求导致的数据混乱 12345678910var requests = &#123;&#125;;$.ajaxPrefilter(function(options,originalOptions,jqXHR)&#123; if(requests[options.url])&#123; requests[options.url].abort(); &#125; requests[options.url] = jqXHR;&#125;);$.ajax('/test/'); // 第一次$.ajax('/test/'); // 第二次 例：统一修改请求路径 12345678910$.ajaxPrefilter(function(options)&#123; if(options.url.substr(0,5) == '/usr')&#123; options.url = options.url.replace('/usr/','/user/'); options.header = &#123; a:1 &#125; &#125;&#125;);$.ajax('/usr/'); 全局事件 jQuery-1.9以后，全局事件必须绑定在document上 $(document).ajaxSuccess(globalEventHander); $(document).ajaxError(globalEventHander); $(document).ajaxComplete(globalEventHander); $(document).ajaxStart(globalEventHander); $(document).ajaxStop(globalEventHander); $(document).ajaxSend(globalEventHander); 123456function globalEventHander(event)&#123; console.log(arguments); console.log(event.type);&#125;$.ajax('/test?err=y');//请求成功$.ajax('/test?err=n');//请求失败 请求顺序:1.ajaxStart2.ajaxSend3.ajaxSuccess4.ajaxError5.ajaxComplete6.ajaxStop 序列化 param：序列化一个 key/value 对象 serialize：通过序列化表单值，创建 URL 编码文本字符串 serializeArray：通过序列化表单值来创建对象数组(名称和值) 例：param() 123var params = &#123; a:1, b:2 &#125;;var str = $.param(params);console.log(str); //a=1&amp;b=2\" 例：serialize() 1234567891011&lt;form&gt; &lt;div&gt;&lt;input type=\"text\" name=\"a\" value=\"1\"/&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"text\" name=\"b\" value=\"2\"/&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"hidden\" name=\"c\" value=\"3\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt; $('form').submit(function() &#123; console.log($(this).serialize()); //a=1&amp;b=2&amp;c=3 return false; &#125;);&lt;/script&gt; 例：serializeArray() 12345678910&lt;form&gt; First:&lt;input type=\"text\" name=\"First\" value=\"1\" /&gt;&lt;br /&gt; Last :&lt;input type=\"text\" name=\"Last\" value=\"2\" /&gt;&lt;br /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt; $('form').click(function()&#123; x=$(\"form\").serializeArray(); console.log(x); //&#123;[name:First,value:1],[name:Last,value:2]&#125; &#125;);&lt;/script&gt;","pubDate":"Mon, 02 Nov 2015 20:29:00 GMT","guid":"//qiangck.club/2015/11/03/jQuery-ajax详解使用方法/","category":"jQuery"},{"title":"HTML5 Audio/Video 使用方法汇总","link":"//qiangck.club/2015/10/31/HTML5-Audio-Video-使用方法汇总/","description":"&lt;audio&gt;标签属性： src：音乐的URL preload：预加载 autoplay：自动播放 loop：循环播放 controls：浏览器自带的控制条 1234&lt;audio id=\"media\" src=\"http://www.abc.com/test.mp3\" controls&gt; &lt;source src=\"http://www.abc.com/test.mp3\" type=\"audio/mp3\"&gt;&lt;/source&gt; &lt;source src=\"http://www.abc.com/test.ogg\" type=\"audio/ogg\"&gt;&lt;/source&gt;&lt;/audio&gt; &lt;video&gt;标签属性： src：视频的URL poster：视频封面，没有播放时显示的图片 preload：预加载 autoplay：自动播放 loop：循环播放 controls：浏览器自带的控制条 width：视频宽度 height：视频高度 1&lt;video id=\"media\" src=\"http://www.abc.com/test.mp4\" controls width=\"400px\" heigt=\"400px\"&gt;&lt;/video&gt; 获取HTMLVideoElement和HTMLAudioElement对象 1234//audio可以直接通过new创建对象Media = new Audio(\"http://www.abc.com/test.mp3\");//audio和video都可以通过标签获取对象Media = document.getElementById(\"media\"); Media方法和属性： 1234567891011121314151617181920212223242526272829303132333435363738394041//错误状态Media.error; //null:正常Media.error.code; //1.用户终止 2.网络错误 3.解码错误 4.URL无效//网络状态Media.currentSrc; //返回当前资源的URLMedia.src = value; //返回或设置当前资源的URLMedia.canPlayType(type); //是否能播放某种格式的资源Media.networkState; //0.此元素未初始化 1.正常但没有使用网络 2.正在下载数据 3.没有找到资源Media.load(); //重新加载src指定的资源Media.buffered; //返回已缓冲区域，TimeRangesMedia.preload; //none:不预载 metadata:预载资源信息 auto://准备状态Media.readyState; //1:HAVE_NOTHING 2:HAVE_METADATA 3.HAVE_CURRENT_DATA 4.HAVE_FUTURE_DATA 5.HAVE_ENOUGH_DATAMedia.seeking; //是否正在seeking//回放状态Media.currentTime = value; //当前播放的位置，赋值可改变位置Media.startTime; //一般为0，如果为流媒体或者不从0开始的资源，则不为0Media.duration; //当前资源长度 流返回无限Media.paused; //是否暂停Media.defaultPlaybackRate = value; //默认的回放速度，可以设置Media.playbackRate = value; //当前播放速度，设置后马上改变Media.played; //返回已经播放的区域，TimeRanges，关于此对象见下文Media.seekable; //返回可以seek的区域 TimeRangesMedia.ended; //是否结束Media.autoPlay; //是否自动播放Media.loop; //是否循环播放Media.play(); //播放Media.pause(); //暂停//控制Media.controls; //是否有默认控制条Media.volume = value; //音量Media.muted = value; //静音//TimeRanges(区域)对象TimeRanges.length; //区域段数TimeRanges.start(index) //第index段区域的开始位置TimeRanges.end(index) //第index段区域的结束位置 事件介绍 1234567891011121314151617181920212223242526eventTester = function(e)&#123; Media.addEventListener(e,function()&#123; console.log((new Date()).getTime(),e); &#125;);&#125;eventTester(\"loadstart\"); //客户端开始请求数据eventTester(\"progress\"); //客户端正在请求数据eventTester(\"suspend\"); //延迟下载eventTester(\"abort\"); //客户端主动终止下载（不是因为错误引起），eventTester(\"error\"); //请求数据时遇到错误eventTester(\"stalled\"); //网速失速eventTester(\"play\"); //play()和autoplay开始播放时触发eventTester(\"pause\"); //pause()触发eventTester(\"loadedmetadata\"); //成功获取资源长度eventTester(\"loadeddata\"); //提示当前帧的数据是可用的eventTester(\"waiting\"); //等待数据，并非错误eventTester(\"playing\"); //开始回放eventTester(\"canplay\"); //可以播放，但中途可能因为加载而暂停eventTester(\"canplaythrough\"); //可以播放，歌曲全部加载完毕eventTester(\"seeking\"); //寻找中eventTester(\"seeked\"); //寻找完毕eventTester(\"timeupdate\"); //播放时间改变eventTester(\"ended\"); //播放结束eventTester(\"ratechange\"); //播放速率改变eventTester(\"durationchange\"); //资源长度改变eventTester(\"volumechange\"); //音量改变","pubDate":"Sat, 31 Oct 2015 07:59:00 GMT","guid":"//qiangck.club/2015/10/31/HTML5-Audio-Video-使用方法汇总/","category":"HTML5"},{"title":"博客的诞生","link":"//qiangck.club/2015/09/24/博客的诞生/","description":"一时兴起建立了此博客，本人是个前端小白，技术不佳，就想留些东西给未来的自己（大牛勿喷哈）。本博客使用了Hexo框架，发布在Github page上面,建立博客属于个人爱好,请勿商业使用,也请转载的朋友请标注好出处和相关内容。 域名的注册 我的域名是在阿里巴巴收购万网后搞活动购买的,当时只要了我20大洋,这个域名我一直搁置了将近一年的时间才开始想弄个博客的。域名的话随便买个就好了,也不是很贵的。 注册GitHub账号 GitHub的注册非常简单： Pick a username:用户名 Your email:邮箱 Create a password:密码 点击Sign up for GitHub注册 使用msysgit管理Github msysgit是 Git 版本控制系统在 Windows 下的版本。 安装与设置 下载msysgit安装非常简单。点击这里百度百科，与Github绑定，使用msysgit找到系统[用户名]文件夹 &gt; .ssh文件夹。 例：C:\\Users\\Administrator.ssh 1234567[~/.ssh]$ ssh-keygen -t rsaGenerating public/private rsa key pair. Enter file in which to save the key (/home/tom/.ssh/id_rsa): [Enter]Enter passphrase (empty for no passphrase): &lt;输入key的密码，或直接按下enter使用空密码&gt;Enter same passphrase again: &lt;再输入一次密码&gt;Your identification has been saved in /home/tom/.ssh/id_rsa.Your public key has been saved in /home/tom/.ssh/id_rsa.pub.The key fingerprint is:50:43:77:c6:97:af:61:82:dc:ea:9b:6b:67:d4:1b:61 tom@volcano 可以直接回车（默认的密码为空）,用编辑器找到ssh文件夹下面的id_rsa.pub，其中id_rsa.pub是公钥，而id_rsa则是私钥,将公钥粘贴到你github帐号中的SSH Keys中。 1Hi han1202012! You've successfully authenticated, but GitHub does not provide shell access。 就说明配置成功, 可以连接上GitHub。","pubDate":"Thu, 24 Sep 2015 04:05:00 GMT","guid":"//qiangck.club/2015/09/24/博客的诞生/","category":"default"}]}